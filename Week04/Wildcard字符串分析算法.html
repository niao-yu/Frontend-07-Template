<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wildcard字符串分析算法</title>
</head>
<body>
  项目功能说明见README.md
</body>
<script>
  function find(source, pattern) {
    let startCount = 0

    for (let i = 0; i < pattern.length; i++) {
      if (pattern[i] === '*') startCount++
    }

    // 没有*, source, pattern 需要是全等(注意里面有?匹配符)
    if (!startCount) {
      // 长度不同
      if (pattern.length !== source.length) {
        return false
      }
      for (let i = 0; i < pattern.length; i++) {
        if (source[i] !== pattern[i] && pattern[i] !== '?') {
          return false
        }
      }
      return true
    } else { // 包含 * , 开始遍历处理

      let i = 0 // 取的 pattern 的索引值
      let lastIndex = i // 正则的 exec 的 lastIndex, 后面会用

      // 判断第一个 * 之前的字符
      {
        for (; pattern[i] !== '*'; i++) {
          if (source[i] !== pattern[i] && pattern[i] !== '?') {
            return false
          }
        }
        lastIndex = i // 更新一下, 让后面校验 source 时, 从 i 这个索引开启(i之前的部分,都是第一个星号之前的,已经匹配完了)
      }

      { // 判断中间部分的匹配
        for (let p = 0; p < startCount - 1; p++) {
          ++i // 注意, 经历了上面和上一个循环的步骤 pattern[i] === '*', 所以 i 需要先加1

          let subPattern = '' // pattern 中, 被 * 分隔的字符串片段
          // pattern 的当前这一项不是 *, 拼接取来, 用来下面的匹配查找
          while (pattern[i] !== '*' && i < pattern.length) {
            subPattern += pattern[i]
            i++
          }

          let Reg = new RegExp(subPattern.replace(/\?/g, '[\\s\\S]'), 'g')

          Reg.lastIndex = lastIndex
          // 没有匹配上
          if (!Reg.exec(source)) {
            return false
          }

          // 这个片段匹配上了, 更新一下 lastIndex, 给下一个循环备用
          lastIndex = Reg.lastIndex
        }

        { // 判断最后一个 * 后面的字符, 必须全字符匹配

          ++i // 注意, 经历了上面和上一个循环的步骤 pattern[i] === '*', 所以 i 需要先加1
          // 最后一个 * 后面还有东西
          if (i < pattern.length) {

            for (let j = 1; pattern[pattern.length - j] !== '*'; j++) {
              let sourceIndex = source.length - j
              if (sourceIndex < lastIndex) {
                // 和上面已经比过的字符重叠了
                return false
              }
              if (source[source.length - j] !== pattern[pattern.length - j] && pattern[pattern.length - j] !== '?') {
                return false
              }
            }
          }
        }
        // 判断完成, 能走到这儿, 匹配通过
        return true
      }
    }
  }

  console.log(find('sfsff', 'sf?f'))
</script>
</html>